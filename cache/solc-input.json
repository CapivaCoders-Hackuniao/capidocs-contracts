{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IPersona.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.7.0;\n\ninterface IPersona {\n\tfunction validatorAnswer(\n\t\tbytes32,\n\t\tuint8,\n\t\tuint256,\n\t\tstring memory\n\t) external;\n\n\tfunction transferOwnershipPersona(address) external;\n\n\tfunction giveCertificate(\n\t\tbytes32,\n\t\tstring memory,\n\t\tstring memory,\n\t\tstring memory\n\t) external;\n}\n"
    },
    "contracts/interfaces/IPersonaFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.7.0;\n\ninterface IPersonaFactory {\n  function newPersona(address, bytes32) external returns (address);\n}\n"
    },
    "contracts/interfaces/IRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.7.0;\n\ninterface IRegistry {\n\tfunction isValidator(address) external returns (bool);\n\n\tfunction isPersona(address) external returns (bool);\n\n\tfunction updatePersonaTransfer(address, address) external;\n\n\tfunction updateValidatorTransfer(address, address) external;\n}\n"
    },
    "contracts/interfaces/IValidator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\ninterface IValidator {\n  function askValidation(\n    bytes32,\n    string[] memory,\n    bytes32[] memory,\n\tstring memory,\n    bytes32\n  ) external;\n\n  function transferOwnershipValidator(address) external;\n\n  function transferOwnershipValidatorPK(address, string memory) external;\n\n}\n"
    },
    "contracts/interfaces/IValidatorFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.7.0;\n\ninterface IValidatorFactory {\n  function newValidator(address, bytes32) external returns (address);\n}\n"
    },
    "contracts/Migrations.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ncontract Migrations {\n  address public owner;\n  uint256 public last_completed_migration;\n\n  constructor() {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint256 completed) public restricted {\n    last_completed_migration = completed;\n  }\n}\n"
    },
    "contracts/Persona.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./vendor/Ownable.sol\";\nimport \"./vendor/AccessControl.sol\";\n\nimport \"./interfaces/IPersona.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/IValidator.sol\";\n\ncontract Persona is Ownable, IPersona {\n\t//Contract Info\n\taddress public registry;\n\tbytes32 public name;\n\n\t//Documents Storage\n\tbytes32[] public documents;\n\tmapping(bytes32 => FieldInfo) public personaInfos;\n\n\t//Certificates Storage\n\tCertificate[] public certificates;\n\tCertificate[] pendingCertificates;\n\n\t//Documents Objects\n\tenum StatusValidation {NotEvaluated, PendingValidation, Validated, NotValidated}\n\n\tstruct FieldInfo {\n\t\tstring baseValue;\n\t\tbytes32 documentValueHash;\n\t\tbytes32[] documentHashes;\n\t\taddress[] validators;\n\t\tmapping(address => ValidatorsAnswer) validatorsAnswersMap;\n\t}\n\n\tstruct ValidatorsAnswer {\n\t\tStatusValidation validation;\n\t\tuint256 validationTimestamp;\n\t\tstring signature;\n\t}\n\n\t//Certificates Objects\n\tstruct Certificate {\n\t\taddress issuer;\n\t\tbytes32 givenName;\n\t\tstring value;\n\t\tstring content;\n\t\tstring signature;\n\t\tuint256 timestamp;\n\t}\n\n\t//Constructor\n\tconstructor(address _registry, bytes32 _name) {\n\t\tname = _name;\n\t\tregistry = _registry;\n\t}\n\n\t//Events\n\tevent personaAskToValidate(\n\t\taddress indexed validatorAddress,\n\t\tbytes32 indexed documentType,\n\t\tstring[] documentLinks,\n\t\tstring documentValue\n\t);\n\n\tevent validatorAnswerValidation(bytes32 indexed documentType, uint8 status, uint256 indexed timestamp, string signature);\n\t\n\tevent newCertificate(address indexed sender, bytes32 indexed name, uint256 indexed timestamp);\n\n\t//View - Documents\n\n\tfunction getDocuments() public view returns (bytes32[] memory){\n\t\treturn documents;\n\t}\n\n\tfunction getValidationStatus(bytes32 documentType, address validator)\n\t\tpublic\n\t\tview\n\t\treturns (\n\t\t\tuint8,\n\t\t\tuint256,\n\t\t\tstring memory\n\t\t)\n\t{\n\t\treturn (\n\t\t\tuint8(personaInfos[documentType].validatorsAnswersMap[validator].validation),\n\t\t\tpersonaInfos[documentType].validatorsAnswersMap[validator].validationTimestamp,\n\t\t\tpersonaInfos[documentType].validatorsAnswersMap[validator].signature\n\t\t);\n\t}\n\n\tfunction getValidators(bytes32 documentType) public view returns (address[] memory) {\n\t\treturn personaInfos[documentType].validators;\n\t}\n\n\tfunction getDocumentHashes(bytes32 documentType) public view returns (bytes32[] memory) {\n\t\treturn personaInfos[documentType].documentHashes;\n\t}\n\n\tfunction personaFieldExists(bytes32 documentType) public view returns (bool) {\n\t\treturn personaInfos[documentType].documentValueHash != bytes32(\"\");\n\t}\n\n\t//View - Certificates\n\n\tfunction getCertificatesCount() public view returns (uint256) {\n\t\treturn certificates.length;\n\t}\n\n\tfunction getPendingCertificatesCount() public view onlyOwner returns (uint256) {\n\t\treturn pendingCertificates.length;\n\t}\n\n\tfunction getCertificate(uint256 index)\n\t\tpublic\n\t\tview\n\t\treturns (\n\t\t\taddress,\n\t\t\tbytes32,\n\t\t\tstring memory,\n\t\t\tstring memory,\n\t\t\tstring memory,\n\t\t\tuint256\n\t\t)\n\t{\n\t\tuint256 length = certificates.length;\n\t\tif (index >= length) return (address(0), bytes32(\"\"), \"\", \"\", \"\", 0);\n\t\treturn (\n\t\t\tcertificates[index].issuer,\n\t\t\tcertificates[index].givenName,\n\t\t\tcertificates[index].value,\n\t\t\tcertificates[index].content,\n\t\t\tcertificates[index].signature,\n\t\t\tcertificates[index].timestamp\n\t\t);\n\t}\n\n\tfunction getLastPendingCertificate()\n\t\tpublic\n\t\tview\n\t\tonlyOwner\n\t\treturns (\n\t\t\taddress,\n\t\t\tbytes32,\n\t\t\tstring memory,\n\t\t\tstring memory,\n\t\t\tstring memory,\n\t\t\tuint256\n\t\t)\n\t{\n\t\tuint256 length = pendingCertificates.length;\n\t\tif (length == 0) return (address(0), bytes32(\"\"), \"\", \"\", \"\", 0);\n\t\treturn (\n\t\t\tpendingCertificates[length - 1].issuer,\n\t\t\tpendingCertificates[length - 1].givenName,\n\t\t\tpendingCertificates[length - 1].value,\n\t\t\tpendingCertificates[length - 1].content,\n\t\t\tpendingCertificates[length - 1].signature,\n\t\t\tpendingCertificates[length - 1].timestamp\n\t\t);\n\t}\n\n\t//Actions - Contract Info\n\n\tfunction changeName(bytes32 _name) public onlyOwner {\n\t\tname = _name;\n\t}\n\n\tfunction transferOwnershipPersona(address newOwner) public override onlyOwner {\n\t\trequire(documents.length == 0, \"Persona: Persona must be empty to transfer\");\n\t\tif (_msgSender() != registry) IRegistry(registry).updatePersonaTransfer(owner(), newOwner);\n\t\ttransferOwnership(newOwner);\n\t}\n\n\t//Actions - Documents\n\n\tfunction addField(\n\t\tbytes32 documentType,\n\t\tstring memory baseValue,\n\t\tbytes32 documentValueHash,\n\t\tbytes32[] memory documentHashes\n\t) public onlyOwner {\n\t\trequire(!personaFieldExists(documentType), \"Persona: Document already added!\");\n\t\trequire(documentValueHash != bytes32(\"\"), \"Persona: Document must not be empty\");\n\t\tpersonaInfos[documentType].baseValue = baseValue;\n\t\tpersonaInfos[documentType].documentHashes = documentHashes;\n\t\tpersonaInfos[documentType].documentValueHash = documentValueHash;\n\t\tdocuments.push(documentType);\n\t}\n\n\tfunction replaceField(\n\t\tbytes32 documentType,\n\t\tstring memory baseValue,\n\t\tbytes32 documentValueHash,\n\t\tbytes32[] memory _documentHashes\n\t) public onlyOwner {\n\t\trequire(documentValueHash != bytes32(\"\"), \"Persona: Document must not be empty\");\n\t\tpersonaInfos[documentType].baseValue = baseValue;\n\t\tpersonaInfos[documentType].documentHashes = _documentHashes;\n\t\tpersonaInfos[documentType].documentValueHash = documentValueHash;\n\t\tpersonaInfos[documentType].validators = new address[](0);\n\t}\n\n\tfunction askToValidate(\n\t\taddress validatorAddress,\n\t\tbytes32 documentType,\n\t\tstring[] memory documentLinks,\n\t\tstring memory documentValue\n\t) public onlyOwner {\n\t\trequire(personaFieldExists(documentType), \"Persona: Document not added\");\n\t\trequire(IRegistry(registry).isValidator(validatorAddress), \"Persona: Address is not registered as validator\");\n\t\trequire(\n\t\t\tpersonaInfos[documentType].validatorsAnswersMap[validatorAddress].validation == StatusValidation.NotEvaluated,\n\t\t\t\"Persona: Validation already requested\"\n\t\t);\n\t\tIValidator(validatorAddress).askValidation(\n\t\t\tdocumentType,\n\t\t\tdocumentLinks,\n\t\t\tpersonaInfos[documentType].documentHashes,\n\t\t\tdocumentValue,\n\t\t\tpersonaInfos[documentType].documentValueHash\n\t\t);\n\t\tpersonaInfos[documentType].validators.push(validatorAddress);\n\t\tpersonaInfos[documentType].validatorsAnswersMap[validatorAddress] = ValidatorsAnswer({\n\t\t\tvalidation: StatusValidation.PendingValidation,\n\t\t\tvalidationTimestamp: 0,\n\t\t\tsignature: \"\"\n\t\t});\n\t\temit personaAskToValidate(validatorAddress, documentType, documentLinks, documentValue);\n\t}\n\n\t//Actions - Documents - External Calls\n\n\tfunction validatorAnswer(\n\t\tbytes32 documentType,\n\t\tuint8 status,\n\t\tuint256 timestamp,\n\t\tstring memory signature\n\t) external override {\n\t\trequire(\n\t\t\tpersonaInfos[documentType].validatorsAnswersMap[_msgSender()].validation == StatusValidation.PendingValidation,\n\t\t\t\"Persona: Validation not requested\"\n\t\t);\n\t\tpersonaInfos[documentType].validatorsAnswersMap[_msgSender()].validation = StatusValidation(status);\n\t\tpersonaInfos[documentType].validatorsAnswersMap[_msgSender()].validationTimestamp = timestamp;\n\t\tpersonaInfos[documentType].validatorsAnswersMap[_msgSender()].signature = signature;\n\t\temit validatorAnswerValidation(documentType, status, timestamp, signature);\n\t}\n\n\t//Actions - Certificates\n\n\t//Certificates are processed in LIFO\n\tfunction processLastPendingCertificate(bool approved) public onlyOwner {\n\t\trequire(pendingCertificates.length > 0, \"Persona: No pending certificates\");\n\t\tif (approved) certificates.push(pendingCertificates[pendingCertificates.length - 1]);\n\t\tpendingCertificates.pop();\n\t}\n\n\t//Give certificate using the Persona contract (signed with the owner)\n\tfunction giveCertificateTo(\n\t\taddress persona,\n\t\tbytes32 givenName,\n\t\tstring memory value,\n\t\tstring memory content,\n\t\tstring memory signature\n\t) public onlyOwner {\n\t\tIPersona(persona).giveCertificate(givenName, value, content, signature);\n\t}\n\n\t//Actions - Certificates - External Calls\n\n\tfunction giveCertificate(\n\t\tbytes32 givenName,\n\t\tstring memory value,\n\t\tstring memory content,\n\t\tstring memory signature\n\t) external override {\n\t\tpendingCertificates.push(Certificate(_msgSender(), givenName, value, content, signature, block.timestamp));\n\t\temit newCertificate(_msgSender(), givenName, block.timestamp);\n\t}\n}\n"
    },
    "contracts/vendor/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n  address private _owner;\n\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n  /**\n   * @dev Initializes the contract setting the deployer as the initial owner.\n   */\n  constructor() {\n    address msgSender = _msgSender();\n    _owner = msgSender;\n    emit OwnershipTransferred(address(0), msgSender);\n  }\n\n  /**\n   * @dev Returns the address of the current owner.\n   */\n  function owner() public view returns (address) {\n    return _owner;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  /**\n   * @dev Leaves the contract without owner. It will not be possible to call\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\n   *\n   * NOTE: Renouncing ownership will leave the contract without an owner,\n   * thereby removing any functionality that is only available to the owner.\n   */\n  function renounceOwnership() public virtual onlyOwner {\n    emit OwnershipTransferred(_owner, address(0));\n    _owner = address(0);\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   * Can only be called by the current owner.\n   */\n  function transferOwnership(address newOwner) public virtual onlyOwner {\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n  }\n}\n"
    },
    "contracts/vendor/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n  function _msgSender() internal virtual view returns (address payable) {\n    return msg.sender;\n  }\n\n  function _msgData() internal virtual view returns (bytes memory) {\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n    return msg.data;\n  }\n}\n"
    },
    "contracts/vendor/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./EnumerableSet.sol\";\nimport \"./Address.sol\";\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Address for address;\n\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n        return _roles[role].members.contains(account);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n        return _roles[role].members.length();\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n        return _roles[role].members.at(index);\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (_roles[role].members.add(account)) {\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (_roles[role].members.remove(account)) {\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "contracts/vendor/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\n * (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint256(_at(set._inner, index)));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}"
    },
    "contracts/vendor/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}"
    },
    "contracts/PersonaFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.7.0;\n\nimport \"./interfaces/IPersonaFactory.sol\";\nimport \"./Persona.sol\";\nimport \"./vendor/AccessControl.sol\";\n\ncontract PersonaFactory is IPersonaFactory, AccessControl {\n  function newPersona(address registry, bytes32 name)\n    public\n    override\n    returns (address personaAddressContract)\n  {\n    Persona persona = new Persona(registry, name);\n    persona.transferOwnership(_msgSender());\n    personaAddressContract = address(persona);\n  }\n}\n"
    },
    "contracts/Registry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.7.0;\n\nimport \"./vendor/AccessControl.sol\";\nimport \"./vendor/Ownable.sol\";\n\nimport \"./interfaces/IPersona.sol\";\nimport \"./interfaces/IValidator.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/IPersonaFactory.sol\";\nimport \"./interfaces/IValidatorFactory.sol\";\n\ncontract Registry is Ownable, AccessControl, IRegistry {\n\tbytes32 public constant PERSONA_ROLE = keccak256(\"PERSONA_ROLE\");\n\tbytes32 public constant VALIDATOR_ROLE = keccak256(\"VALIDATOR_ROLE\");\n\tbytes32 public constant ACC_MANAGER_ROLE = keccak256(\"ACC_MANAGER_ROLE\");\n\n\t//Factory\n\taddress public personaFactory;\n\taddress public validatorFactory;\n\n\tmapping(address => address) public ownerToPersona;\n\tmapping(address => address) public ownerToValidator;\n\n\tbytes32 public name;\n\tbool public requireRolePersona;\n\tbool public requireRoleValidator;\n\n\tconstructor(\n\t\tbytes32 _name,\n\t\tbool _requireRolePersona,\n\t\tbool _requireRoleValidator,\n\t\taddress personaFactoryAddress,\n\t\taddress validatorFactoryAddress\n\t) {\n\t\tname = _name;\n\t\t_setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\t\t_setupRole(ACC_MANAGER_ROLE, _msgSender());\n    \t_setRoleAdmin(PERSONA_ROLE, ACC_MANAGER_ROLE);\n   \t\t_setRoleAdmin(VALIDATOR_ROLE, ACC_MANAGER_ROLE);\n\t\trequireRolePersona = _requireRolePersona;\n\t\trequireRoleValidator = _requireRoleValidator;\n\t\tpersonaFactory = personaFactoryAddress;\n\t\tvalidatorFactory = validatorFactoryAddress;\n\t}\n\n\tfunction changeName(bytes32 _name) public onlyOwner {\n\t\tname = _name;\n\t}\n\n\tfunction changeRequireRolePersona(bool _requireRolePersona) public onlyOwner {\n\t\trequireRolePersona = _requireRolePersona;\n\t}\n\n\tfunction changeRequireRoleValidator(bool _requireRoleValidator) public onlyOwner {\n\t\trequireRoleValidator = _requireRoleValidator;\n\t}\n\n\tfunction updateFactoryAddresses(address personaFactoryAddress, address validatorFactoryAddress) public onlyOwner {\n\t\tpersonaFactory = personaFactoryAddress == address(0) ? personaFactory : personaFactoryAddress;\n\t\tvalidatorFactory = validatorFactoryAddress == address(0) ? validatorFactory : validatorFactoryAddress;\n\t}\n\n\tfunction updatePersonaTransfer(address owner, address newOwner) external override {\n\t\trequire(ownerToPersona[owner] == _msgSender(), \"Registry: Not Owner\");\n\t\townerToPersona[newOwner] = _msgSender();\n\t\townerToPersona[owner] = address(0);\n\t}\n\n\tfunction updateValidatorTransfer(address owner, address newOwner) external override {\n\t\trequire(ownerToValidator[owner] == _msgSender(), \"Registry: Not Owner\");\n\t\townerToValidator[newOwner] = _msgSender();\n\t\townerToValidator[owner] = address(0);\n\t}\n\n\tfunction isValidator(address addr) public override view returns (bool) {\n\t\treturn hasRole(VALIDATOR_ROLE, addr);\n\t}\n\n\tfunction isPersona(address addr) public override view returns (bool) {\n\t\treturn hasRole(PERSONA_ROLE, addr);\n\t}\n\n\tfunction personaSelfRegistry(bytes32 _name) public {\n\t\trequire(!requireRolePersona, \"Registry: Self registry disabled\");\n\t\tnewPersona(_msgSender(), _name);\n\t}\n\n\tfunction validatorSelfRegistry(bytes32 _name, string memory pubKey) public {\n\t\trequire(!requireRoleValidator, \"Registry: Self registry disabled\");\n\t\tnewValidator(_msgSender(), _name, pubKey);\n\t}\n\n\tfunction personaCreateRegistry(address accOwner, bytes32 _name) public {\n\t\trequire(hasRole(ACC_MANAGER_ROLE, _msgSender()));\n\t\tnewPersona(accOwner, _name);\n\t}\n\n\tfunction validatorCreateRegistry(address accOwner, bytes32 _name, string memory pubKey) public {\n\t\trequire(hasRole(ACC_MANAGER_ROLE, _msgSender()));\n\t\tnewValidator(accOwner, _name, pubKey);\n\t}\n\n\tfunction newPersona(address accOwner, bytes32 _name) internal returns (address) {\n\t\trequire(ownerToPersona[accOwner] == address(0), \"Registry: persona already registered\");\n\t\taddress persona = IPersonaFactory(personaFactory).newPersona(address(this), _name);\n\t\townerToPersona[accOwner] = persona;\n\t\tIPersona(persona).transferOwnershipPersona(accOwner);\n\t\t_setupRole(PERSONA_ROLE, persona);\n\t\treturn persona;\n\t}\n\n\tfunction newValidator(address accOwner, bytes32 _name, string memory pubKey) internal returns (address) {\n\t\trequire(ownerToValidator[accOwner] == address(0), \"Registry: validator already registered\");\n\t\taddress validator = IValidatorFactory(validatorFactory).newValidator(address(this), _name);\n\t\townerToValidator[accOwner] = validator;\n\t\tIValidator(validator).transferOwnershipValidatorPK(accOwner, pubKey);\n\t\t_setupRole(VALIDATOR_ROLE, validator);\n\t\treturn validator;\n\t}\n}\n"
    },
    "contracts/Validator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./interfaces/IValidator.sol\";\nimport \"./interfaces/IPersona.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./vendor/Ownable.sol\";\nimport \"./vendor/SafeMath.sol\";\nimport \"./vendor/MyUtils.sol\";\n\ncontract Validator is Ownable, IValidator {\n\tusing SafeMath for uint256;\n\n\t//Contract Info\n\tbytes32 public name;\n\taddress public registry;\n\taddress public paymentToken;\n\tstring public ownerPublicKey;\n\n\t//Validator Configs\n\tmapping(bytes32 => bool) public documentTypes;\n\tmapping(bytes32 => uint256) public documentPrices;\n\n\t//Validator Queue\n\tmapping(uint256 => validation) public validationQueue;\n\tuint256 public validationQueueStart;\n\tuint256 public validationQueueEnd;\n\n\t//Validator Objects\n\tstruct validation {\n\t\taddress persona;\n\t\tbytes32 documentType;\n\t\tstring[] documentLinks;\n\t\tbytes32[] documentHashes;\n\t\tstring documentValue;\n\t\tbytes32 documentValueHash;\n\t\tbool processed;\n\t}\n\n\t//Constructor\n\tconstructor(address _registry, bytes32 _name) {\n\t\tname = _name;\n\t\tregistry = _registry;\n\t\tvalidationQueueStart = 1;\n\t\tvalidationQueueEnd = 0;\n\t}\n\n\tevent newValidationRequest(address indexed sender, bytes32 indexed documentType);\n\n\t//View\n\n\tfunction getNextValidation()\n\t\tpublic\n\t\tview\n\t\treturns (\n\t\t\taddress persona,\n\t\t\tbytes32 documentType,\n\t\t\tstring[] memory documentLinks,\n\t\t\tbytes32[] memory documentHashes,\n\t\t\tstring memory documentValue,\n\t\t\tbytes32 documentValueHash\n\t\t)\n\t{\n\t\treturn (\n\t\t\tvalidationQueue[validationQueueStart].persona,\n\t\t\tvalidationQueue[validationQueueStart].documentType,\n\t\t\tvalidationQueue[validationQueueStart].documentLinks,\n\t\t\tvalidationQueue[validationQueueStart].documentHashes,\n\t\t\tvalidationQueue[validationQueueStart].documentValue,\n\t\t\tvalidationQueue[validationQueueStart].documentValueHash\n\t\t);\n\t}\n\n\tfunction getValidationAt(uint256 index)\n\t\tpublic\n\t\tview\n\t\treturns (\n\t\t\taddress persona,\n\t\t\tbytes32 documentType,\n\t\t\tstring[] memory documentLinks,\n\t\t\tbytes32[] memory documentHashes,\n\t\t\tstring memory documentValue,\n\t\t\tbytes32 documentValueHash\n\t\t)\n\t{\n\t\treturn (\n\t\t\tvalidationQueue[index].persona,\n\t\t\tvalidationQueue[index].documentType,\n\t\t\tvalidationQueue[index].documentLinks,\n\t\t\tvalidationQueue[index].documentHashes,\n\t\t\tvalidationQueue[index].documentValue,\n\t\t\tvalidationQueue[index].documentValueHash\n\t\t);\n\t}\n\n\t//Actions - Contract Info\n\n\tfunction changeName(bytes32 _name) public onlyOwner {\n\t\tname = _name;\n\t}\n\n\tfunction setPaymentToken(address token) public onlyOwner {\n\t\tpaymentToken = token;\n\t}\n\n\tfunction transferOwnershipValidatorPK(address newOwner, string memory _ownerPublicKey) public override {\n\t\ttransferOwnershipValidator(newOwner);\n\t\townerPublicKey = _ownerPublicKey;\n\t}\n\n\tfunction transferOwnershipValidator(address newOwner) public override {\n\t\trequire(validationQueueStart > validationQueueEnd, \"Validator: Can not transfer with open queue\");\n\t\tif (_msgSender() != registry) IRegistry(registry).updateValidatorTransfer(owner(), newOwner);\n\t\ttransferOwnership(newOwner);\n\t}\n\n\t//Actions - Validator Configs\n\n\tfunction setDocumentPrices(bytes32[] memory _documentTypes, uint256[] memory _documentPrices) public onlyOwner {\n\t\tfor (uint256 i; i < _documentTypes.length; i++) {\n\t\t\tsetDocumentPrice(_documentTypes[i], _documentPrices[i]);\n\t\t}\n\t}\n\n\tfunction setDocumentPrice(bytes32 documentType, uint256 documentPrice) public onlyOwner {\n\t\tdocumentPrices[documentType] = documentPrice;\n\t}\n\n\tfunction addDocumentTypes(bytes32[] memory _documentTypes) public onlyOwner {\n\t\tfor (uint256 i; i < _documentTypes.length; i++) {\n\t\t\taddDocumentType(_documentTypes[i]);\n\t\t}\n\t}\n\n\tfunction addDocumentType(bytes32 documentType) public onlyOwner {\n\t\tdocumentTypes[documentType] = true;\n\t}\n\n\tfunction removeDocumentTypes(bytes32[] memory _documentTypes) public onlyOwner {\n\t\tfor (uint256 i; i < _documentTypes.length; i++) {\n\t\t\tremoveDocumentType(_documentTypes[i]);\n\t\t}\n\t}\n\n\tfunction removeDocumentType(bytes32 documentType) public onlyOwner {\n\t\tdocumentTypes[documentType] = false;\n\t}\n\n\t//Actions - Validator\n\n\t//Validations are processed in FIFO\n\tfunction processValidation(uint8 status, string memory signature) public onlyOwner {\n\t\trequire(validationQueueStart <= validationQueueEnd, \"Validator: Queue empty\");\n\t\tif (!validationQueue[validationQueueStart].processed) {\n\t\t\tIPersona(validationQueue[validationQueueStart].persona).validatorAnswer(\n\t\t\t\tvalidationQueue[validationQueueStart].documentType,\n\t\t\t\tstatus,\n\t\t\t\tblock.timestamp,\n\t\t\t\tsignature\n\t\t\t);\n\t\t\tvalidationQueue[validationQueueStart].processed = true;\n\t\t}\n\t\tvalidationQueueStart = validationQueueStart.add(1);\n\t}\n\n\t//Use with caution\n\tfunction processValidationAt(\n\t\tuint256 index,\n\t\tuint8 status,\n\t\tstring memory signature\n\t) public onlyOwner {\n\t\trequire(!validationQueue[index].processed, \"Validator: Already processed\");\n\t\tIPersona(validationQueue[index].persona).validatorAnswer(validationQueue[index].documentType, status, block.timestamp, signature);\n\t\tvalidationQueue[index].processed = true;\n\t}\n\n\t//Actions - Extenal - Persona\n\n\tfunction askValidation(\n\t\tbytes32 documentType,\n\t\tstring[] memory documentLinks,\n\t\tbytes32[] memory documentHashes,\n\t\tstring memory documentValue,\n\t\tbytes32 documentValueHash\n\t) external override {\n\t\trequire(IRegistry(registry).isPersona(_msgSender()), \"Validator: Address is not registered as validator\");\n\t\trequire(documentTypes[documentType], \"Validator: Validator does not validate this kind of document\");\n\t\tvalidationQueueEnd = validationQueueEnd.add(1);\n\t\tvalidationQueue[validationQueueEnd].persona = _msgSender();\n\t\tvalidationQueue[validationQueueEnd].documentType = documentType;\n\t\tvalidationQueue[validationQueueEnd].documentLinks = documentLinks;\n\t\tvalidationQueue[validationQueueEnd].documentHashes = documentHashes;\n\t\tvalidationQueue[validationQueueEnd].documentValue = documentValue;\n\t\tvalidationQueue[validationQueueEnd].documentValueHash = documentValueHash;\n\t\tif (documentPrices[documentType] > 0) processPayment(documentPrices[documentType]);\n\t\temit newValidationRequest(_msgSender(), documentType);\n\t}\n\n\tfunction processPayment(uint256 price) internal {\n\t\trequire(paymentToken != address(0), \"Validator: Payment Token is not set up\");\n\t\tTransferHelper.safeTransferFrom(paymentToken, _msgSender(), owner(), price);\n\t}\n}\n"
    },
    "contracts/vendor/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/vendor/MyUtils.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.7.0;\n\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}"
    },
    "contracts/ValidatorFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.7.0;\n\nimport \"./interfaces/IValidatorFactory.sol\";\nimport \"./Validator.sol\";\nimport \"./vendor/AccessControl.sol\";\n\ncontract ValidatorFactory is IValidatorFactory, AccessControl {\n  function newValidator(address registry, bytes32 name)\n    public\n    override\n    returns (address validatorAddressContract)\n  {\n    Validator validator = new Validator(registry, name);\n    validator.transferOwnership(_msgSender());\n    validatorAddressContract = address(validator);\n  }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}